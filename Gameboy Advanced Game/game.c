#include "game.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/garbage.h"
#include "images/pikachu.h"
#include "images/gticon.h"
#include "images/3ds.h"
#include "images/mario.h"

/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  HAVENOTSTART,
  START,
  BEFOREGAME,
  PLAY,
  WIN,
  LOSE,
} GBAState;

// TODO: Move these prototypes to .h file
// void reset();
// void waitForVblank(void);
// void reset() {
//   if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
//           state = START;
//   }
// }
// Total initial lives: 


int main(void) {
  int lives = 3;
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  // My code:
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
  GBAState state = START;
  // Have a variable for previous state
  GBAState previous_state = HAVENOTSTART;
  

  // Initialize the state of the moving object for the first round
        cs.ball.row = 80;
        cs.ball.col = 120;
        cs.ball.rd = 1;
        cs.ball.cd = 1;
        cs.ball.image = mario;
        cs.size = 40;

  // Initialize the state of the character for the first round
        ccharacter.ball.row = 50;
        ccharacter.ball.col = 20;
        ccharacter.ball.rd = 2;
        ccharacter.ball.cd = 2;
        ccharacter.ball.color = YELLOW;
        ccharacter.size = 5;
        


  // game loop
  while (1) {
    waitForVBlank();
    
    currentButtons = BUTTONS;  // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case HAVENOTSTART:
        break;
      case START:
        if (previous_state != START) {
          drawFullScreenImageDMA(ds);
        }
        startscreen();
        backToMainInstruction();
        // if the previous state is not play
        //    - redraw the whole thing when change state
        if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
            // 1) Change State
            state = BEFOREGAME;
            previous_state = START;
            // 2) Redraw
            fillScreenDMA(BLACK); 
        }
        
        previous_state = START;
        break;

      case BEFOREGAME:
        if (previous_state != BEFOREGAME) {
            fillScreenDMA(BLACK); 
            reset();
            //lives = 3;
        }
        previous_state = BEFOREGAME;
        state = PLAY;

        break;
      case PLAY:
        // lives = 3;
        ps = cs;

        // Lives String: 
        char buf[8];
        sprintf(buf, "Lives: %d", lives);
        drawString(10, 10, buf , WHITE);

        // Draw PIKACHU picture:
        drawImageDMA(100, 180, 50, 50, pikachu);


        movingObject();
        // Erase the previous moving objects
        drawRectDMA(ps.ball.row, ps.ball.col, ps.size, ps.size, BLACK);
        // Draw the new moving objects
        drawImageDMA(cs.ball.row, cs.ball.col, cs.size, cs.size, cs.ball.image);
        // drawRectDMA(cs.ball.row, cs.ball.col, cs.size, cs.size, cs.ball.color);

        pcharacter = ccharacter;
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
            movingCharacterRight();
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          movingCharacterLeft();
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          movingCharacterUP();
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          movingCharacterDown();
        }
        
        // Erase the previous moving objects
        drawRectDMA(pcharacter.ball.row, pcharacter.ball.col, pcharacter.size, pcharacter.size, BLACK);
        // Draw the new moving objects
        drawRectDMA(ccharacter.ball.row, ccharacter.ball.col, ccharacter.size, ccharacter.size, ccharacter.ball.color);
        // drawRectDMA(cs.ball.row, cs.ball.col, cs.size, cs.size, cs.ball.color);

        // WHEN COLLIDE WITH THE OBJECT:
        int corner1_row = ccharacter.ball.row;
        int corner1_col = ccharacter.ball.col;
        int corner2_row = ccharacter.ball.row;
        int corner2_col = ccharacter.ball.col + ccharacter.size;
        int corner3_row = ccharacter.ball.row + ccharacter.size;
        int corner3_col = ccharacter.ball.col + ccharacter.size;
        int corner4_row = ccharacter.ball.row + ccharacter.size;
        int corner4_col = ccharacter.ball.col;
        int len = cs.size;
        if (
          (corner1_row >= cs.ball.row) && (corner1_row <= (cs.ball.row + len)) &&
          (corner1_col >= cs.ball.col) && (corner1_col <= (cs.ball.col + len))
        ) {
          reset();
          lives = lives - 1;
          sprintf(buf, "Lives: %d", lives);
          drawString(10, 10, buf , WHITE);
          previous_state = PLAY;
          state = BEFOREGAME;
        }
        if (
          (corner2_row >= cs.ball.row) && (corner2_row <= (cs.ball.row + len)) &&
          (corner2_col >= cs.ball.col) && (corner2_col <= (cs.ball.col + len))
        ) {
          reset();
          lives = lives - 1;
          sprintf(buf, "Lives: %d", lives);
          drawString(10, 10, buf , WHITE);
          previous_state = PLAY;
          state = BEFOREGAME;
        }
        if (
          (corner3_row >= cs.ball.row) && (corner3_row <= (cs.ball.row + len)) &&
          (corner3_col >= cs.ball.col) && (corner3_col <= (cs.ball.col + len))
        ) {
          reset();
          lives = lives - 1;
          sprintf(buf, "Lives: %d", lives);
          drawString(10, 10, buf , WHITE);
          previous_state = PLAY;
          state = BEFOREGAME;
        }
        if (
          (corner4_row >= cs.ball.row) && (corner4_row <= (cs.ball.row + len)) &&
          (corner4_col >= cs.ball.col) && (corner4_col <= (cs.ball.col + len))
        ) {
          reset();
          lives = lives - 1;
          sprintf(buf, "Lives: %d", lives);
          drawString(10, 10, buf , WHITE);
          previous_state = PLAY;
          state = BEFOREGAME;
        }
        
        // LOSING STATE
        if (lives<=0) {
          state = LOSE;
        }

        // When Win:
        if (
          (corner1_row >= 100) && (corner1_row <= (150)) &&
          (corner1_col >= 180) && (corner1_col <= (230))
        ) {
          state = WIN;
        }
        if (
          (corner2_row >= 100) && (corner2_row <= (150)) &&
          (corner2_col >= 180) && (corner2_col <= (230))
        ) {
          state = WIN;
        }
        if (
          (corner3_row >= 100) && (corner3_row <= (150)) &&
          (corner3_col >= 180) && (corner3_col <= (230))
        ) {
          state = WIN;
        }
        if (
          (corner4_row >= 100) && (corner4_row <= (150)) &&
          (corner4_col >= 180) && (corner4_col <= (230))
        ) {
          state = WIN;
        }

        // TESTING CODE for state change TO WIN: //
        // if (KEY_DOWN(BUTTON_A, currentButtons) && !KEY_DOWN(BUTTON_A, previousButtons)) {
        //     state = LOSE;
        //     previous_state = START;
        // }
        // TESTING CODE for state change FROM START: //
        
        previous_state = PLAY;
        break;

      case WIN:
        if (previous_state != WIN) {
          drawFullScreenImageDMA(gticon);
        }
        endscreen01();
        backToMainInstruction();
        // state = ?
        previous_state = WIN;
        break;

      case LOSE:
        if (previous_state != LOSE) {
          drawFullScreenImageDMA(garbage);
        }
        endscreen02();
        backToMainInstruction();
        reset();
        previous_state = LOSE;
        break;
    }

  // For Reset:
  if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !KEY_DOWN(BUTTON_SELECT, previousButtons)) {
    drawFullScreenImageDMA(ds);
    startscreen();
    reset();
    lives = 3;
    // Save current and previous state of button input.
    previousButtons = BUTTONS;
    currentButtons = BUTTONS;

    // RE-Load initial game state
    state = START;
    // Have a variable for previous state
    previous_state = HAVENOTSTART;
  }

  previousButtons = currentButtons;  // Store the current state of the buttons
  
    // Wait for Vblank
    waitForVBlank();

    // When play state:
		
    
  }

  // UNUSED(previousButtons);  // You can remove this once previousButtons is used

  return 0;
}


// TODO:
// You will need to implmement undraw(), in order to redraw the background over a small image (e.g. your moving character).
// - Hint: Copy a small rectangle, cropped out of the bg image, on top of the old location of the small image you want to erase. Do NOT redraw the entire background. (That is too slow.)
// - The offset into your bg image is the same math as the offset into videobuffer.
// undraw()

// Helper 1: 
void startscreen(void) {
  // 1) String instruction
  drawString(10, 10,"Press ENTER to move on", RED);
}

// Helper 2: 
void endscreen01(void) {
  // 1) String instruction
  drawString(10, 10,"GAME END YOU WIN", BLUE);
}

// Helper 3:
void endscreen02(void) {
  // 1) String instruction
  drawString(10, 10,"GAME END YOU lOSE", GREEN);
}

// Helper 4:
void backToMainInstruction(void) {
  // 1) String instruction
  drawString(25, 10,"Press Backspace to restart", BLUE);
}

// Helper 5:
// void Lives(int lives) {
//   // 1) String instruction
  // char buf[8];
  // sprintf(buf, "Lives: %d", lives);
  // drawString(10, 10, buf , WHITE);
// }

// Helper 6:
void movingObject(void) {
    cs.ball.row = cs.ball.row + cs.ball.rd;
		cs.ball.col += cs.ball.cd;
		if(cs.ball.row < 0) {
			cs.ball.row = 0;
			cs.ball.rd = -cs.ball.rd;
		}
		if(cs.ball.row > 159-cs.size+1) {
			cs.ball.row = 159-cs.size+1;
			cs.ball.rd = -cs.ball.rd;
		}
		if(cs.ball.col < 0) {
			cs.ball.col = 0;
			cs.ball.cd = -cs.ball.cd;
		}
		if(cs.ball.col > 239-cs.size+1) {
			cs.ball.col = 239-cs.size+1;
			cs.ball.cd = -cs.ball.cd;
		}
    
    // // Erase the previous objects
    //     drawRectDMA(ps.ball.row, ps.ball.col, ps.size, ps.size, BLACK);
    //     // Draw the new objects
    //     drawRectDMA(cs.ball.row, cs.ball.col, cs.size, cs.size, cs.ball.color);
}

// Helper 7:
void movingCharacterRight(void) {
    // ccharacter.ball.row = ccharacter.ball.row + ccharacter.ball.rd;
		// ccharacter.ball.col += ccharacter.ball.cd;
    ccharacter.ball.col += ccharacter.ball.cd;
		if(ccharacter.ball.row < 0) {
			ccharacter.ball.row = 0;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.row > 159-ccharacter.size+1) {
			ccharacter.ball.row = 159-ccharacter.size+1;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.col < 0) {
			ccharacter.ball.col = 0;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		if(ccharacter.ball.col > 239-ccharacter.size+1) {
			ccharacter.ball.col = 239-ccharacter.size+1;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
}

// Helper 8: 
void movingCharacterLeft(void) {
    // ccharacter.ball.row = ccharacter.ball.row + ccharacter.ball.rd;
		// ccharacter.ball.col += ccharacter.ball.cd;
    ccharacter.ball.col -= ccharacter.ball.cd;
    if(ccharacter.ball.row < 0) {
			ccharacter.ball.row = 0;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.row > 159-ccharacter.size+1) {
			ccharacter.ball.row = 159-ccharacter.size+1;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.col < 0) {
			ccharacter.ball.col = 0;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		if(ccharacter.ball.col > 239-ccharacter.size+1) {
			ccharacter.ball.col = 239-ccharacter.size+1;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		// if(ccharacter.ball.row < 0) {
		// 	ccharacter.ball.row = 0;
		// 	ccharacter.ball.rd = -ccharacter.ball.rd;
		// }
		// if(ccharacter.ball.row > 159-ccharacter.size+1) {
		// 	ccharacter.ball.row = 159-ccharacter.size+1;
		// 	ccharacter.ball.rd = -ccharacter.ball.rd;
		// }
		// if(ccharacter.ball.col < 0) {
		// 	ccharacter.ball.col = 0;
		// 	ccharacter.ball.cd = -ccharacter.ball.cd;
		// }
		// if(ccharacter.ball.col > 239-ccharacter.size+1) {
		// 	ccharacter.ball.col = 239-ccharacter.size+1;
		// 	ccharacter.ball.cd = -ccharacter.ball.cd;
		// }
    
}

// Helper 9: 
void movingCharacterUP(void) {
    // ccharacter.ball.row = ccharacter.ball.row + ccharacter.ball.rd;
		// ccharacter.ball.col += ccharacter.ball.cd;
    ccharacter.ball.row -= ccharacter.ball.rd;
    if(ccharacter.ball.row < 0) {
			ccharacter.ball.row = 0;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.row > 159-ccharacter.size+1) {
			ccharacter.ball.row = 159-ccharacter.size+1;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.col < 0) {
			ccharacter.ball.col = 0;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		if(ccharacter.ball.col > 239-ccharacter.size+1) {
			ccharacter.ball.col = 239-ccharacter.size+1;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		// if(ccharacter.ball.row < 0) {
		// 	ccharacter.ball.row = 0;
    //   // This line is for collision:
		// 	ccharacter.ball.rd = -ccharacter.ball.rd;
		// }
		// if(ccharacter.ball.row > 159-ccharacter.size+1) {
		// 	ccharacter.ball.row = 159-ccharacter.size+1;
		// 	ccharacter.ball.rd = -ccharacter.ball.rd;
		// }
		// if(ccharacter.ball.col < 0) {
		// 	ccharacter.ball.col = 0;
		// 	ccharacter.ball.cd = -ccharacter.ball.cd;
		// }
		// if(ccharacter.ball.col > 239-ccharacter.size+1) {
		// 	ccharacter.ball.col = 239-ccharacter.size+1;
		// 	ccharacter.ball.cd = -ccharacter.ball.cd;
		// }
    
}

// Helper 10: 
void movingCharacterDown(void) {
    // ccharacter.ball.row = ccharacter.ball.row + ccharacter.ball.rd;
		// ccharacter.ball.col += ccharacter.ball.cd;
    ccharacter.ball.row += ccharacter.ball.rd;
    if(ccharacter.ball.row < 0) {
			ccharacter.ball.row = 0;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.row > 159-ccharacter.size+1) {
			ccharacter.ball.row = 159-ccharacter.size+1;
			//ccharacter.ball.rd = -ccharacter.ball.rd;
		}
		if(ccharacter.ball.col < 0) {
			ccharacter.ball.col = 0;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		if(ccharacter.ball.col > 239-ccharacter.size+1) {
			ccharacter.ball.col = 239-ccharacter.size+1;
			//ccharacter.ball.cd = -ccharacter.ball.cd;
		}
		// if(ccharacter.ball.row < 0) {
		// 	ccharacter.ball.row = 0;
		// 	ccharacter.ball.rd = -ccharacter.ball.rd;
		// }
		// if(ccharacter.ball.row > 159-ccharacter.size+1) {
		// 	ccharacter.ball.row = 159-ccharacter.size+1;
		// 	ccharacter.ball.rd = -ccharacter.ball.rd;
		// }
		// if(ccharacter.ball.col < 0) {
		// 	ccharacter.ball.col = 0;
		// 	ccharacter.ball.cd = -ccharacter.ball.cd;
		// }
		// if(ccharacter.ball.col > 239-ccharacter.size+1) {
		// 	ccharacter.ball.col = 239-ccharacter.size+1;
		// 	ccharacter.ball.cd = -ccharacter.ball.cd;
		// }
    
}

// Helper 11:
int collision(void) {
    int square_min_row = ccharacter.ball.row;
    int square_min_col = ccharacter.ball.col;
    int square_max_row = ccharacter.ball.row + ccharacter.size;
    int square_max_col = ccharacter.ball.col + ccharacter.size;
    // int len = ccharacter.size;
    if (
      (square_min_row <= cs.ball.row && square_min_row <= (cs.ball.row+cs.size)) ||
      (square_min_col <= cs.ball.col && square_min_col <= (cs.ball.col+cs.size)) ||
      (square_max_row <= cs.ball.row && square_max_row <= (cs.ball.row+cs.size)) ||
      (square_max_col <= cs.ball.col && square_max_col <= (cs.ball.col+cs.size)) 
    ) {
              // lives = lives - 1;
              return 1;
    }


    return 0;
}

// Helper 12:
void reset(void) {
  // Initialize the state of the moving object for the first round
        cs.ball.row = 80;
        cs.ball.col = 120;
        cs.ball.rd = 1;
        cs.ball.cd = 1;
        cs.ball.image = mario;
        cs.size = 40;

  // Initialize the state of the character for the first round
        ccharacter.ball.row = 50;
        ccharacter.ball.col = 20;
        ccharacter.ball.rd = 2;
        ccharacter.ball.cd = 2;
        ccharacter.ball.color = YELLOW;
        ccharacter.size = 5;
  // fillScreenDMA(BLACK);
}



